//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_b "fmt";_e "github.com/laduygaga/unipdf/v3/common";_fa "math";);func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_db Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bg :=x *_db [0]+y *_db [3]+_db [6];
_cd :=x *_db [1]+y *_db [4]+_db [7];return _bg ,_cd ;};func (_gbf Point )Rotate (theta float64 )Point {_ded :=_fa .Hypot (_gbf .X ,_gbf .Y );_bad :=_fa .Atan2 (_gbf .Y ,_gbf .X );_aa ,_aad :=_fa .Sincos (_bad +theta /180.0*_fa .Pi );return Point {_ded *_aad ,_ded *_aa };
};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_g Matrix )Translate (tx ,ty float64 )Matrix {return _g .Mult (TranslationMatrix (tx ,ty ))};func (_dfb Matrix )Inverse ()(Matrix ,bool ){_fbd ,_agd :=_dfb [0],_dfb [1];_dg ,_dfa :=_dfb [3],_dfb [4];
_fc ,_af :=_dfb [6],_dfb [7];_cb :=_fbd *_dfa -_agd *_dg ;if _fa .Abs (_cb )< _afb {return Matrix {},false ;};_egg ,_cf :=_dfa /_cb ,-_agd /_cb ;_dgf ,_aca :=-_dg /_cb ,_fbd /_cb ;_gbg :=-(_egg *_fc +_dgf *_af );_fbb :=-(_cf *_fc +_aca *_af );return NewMatrix (_egg ,_cf ,_dgf ,_aca ,_gbg ,_fbb ),true ;
};func (_cg Matrix )ScalingFactorY ()float64 {return _fa .Hypot (_cg [3],_cg [4])};func (_ef Matrix )String ()string {_eg ,_da ,_c ,_dc ,_bf ,_de :=_ef [0],_ef [1],_ef [3],_ef [4],_ef [6],_ef [7];return _b .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_eg ,_da ,_c ,_dc ,_bf ,_de );
};func (_dea *Matrix )Concat (b Matrix ){*_dea =Matrix {b [0]*_dea [0]+b [1]*_dea [3],b [0]*_dea [1]+b [1]*_dea [4],0,b [3]*_dea [0]+b [4]*_dea [3],b [3]*_dea [1]+b [4]*_dea [4],0,b [6]*_dea [0]+b [7]*_dea [3]+_dea [6],b [6]*_dea [1]+b [7]*_dea [4]+_dea [7],1};
_dea .clampRange ();};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ac :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ac .clampRange ();return _ac ;};func (_ad *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ad [0],_ad [1]=a ,b ;_ad [3],_ad [4]=c ,d ;_ad [6],_ad [7]=tx ,ty ;
_ad .clampRange ();};const _bgd =1e-10;func (_df *Matrix )Shear (x ,y float64 ){_df .Concat (ShearMatrix (x ,y ))};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ee Matrix )Rotate (theta float64 )Matrix {return _ee .Mult (RotationMatrix (theta ))};
func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func RotationMatrix (angle float64 )Matrix {_a :=_fa .Cos (angle );_bb :=_fa .Sin (angle );return NewMatrix (_a ,_bb ,-_bb ,_a ,0,0);};func (_ge Matrix )Singular ()bool {return _fa .Abs (_ge [0]*_ge [4]-_ge [1]*_ge [3])< _bgd };
func (_bacf *Point )transformByMatrix (_cfa Matrix ){_bacf .X ,_bacf .Y =_cfa .Transform (_bacf .X ,_bacf .Y );};func (_d Matrix )Identity ()bool {return _d [0]==1&&_d [1]==0&&_d [2]==0&&_d [3]==0&&_d [4]==1&&_d [5]==0&&_d [6]==0&&_d [7]==0&&_d [8]==1;
};func (_ab Point )Displace (delta Point )Point {return Point {_ab .X +delta .X ,_ab .Y +delta .Y }};func (_bgc Matrix )Angle ()float64 {_ga :=_fa .Atan2 (-_bgc [1],_bgc [0]);if _ga < 0.0{_ga +=2*_fa .Pi ;};return _ga /_fa .Pi *180.0;};func (_ba Matrix )Scale (xScale ,yScale float64 )Matrix {return _ba .Mult (ScaleMatrix (xScale ,yScale ))};
func (_ag *Matrix )Clone ()Matrix {return NewMatrix (_ag [0],_ag [1],_ag [3],_ag [4],_ag [6],_ag [7])};func (_ade Matrix )ScalingFactorX ()float64 {return _fa .Hypot (_ade [0],_ade [1])};func (_fbbd Point )Distance (b Point )float64 {return _fa .Hypot (_fbbd .X -b .X ,_fbbd .Y -b .Y )};
func (_bfb *Matrix )clampRange (){for _agb ,_bac :=range _bfb {if _bac > _eea {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_bac ,_eea );_bfb [_agb ]=_eea ;}else if _bac < -_eea {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_bac ,-_eea );
_bfb [_agb ]=-_eea ;};};};const _eea =1e9;func (_ec Matrix )Round (precision float64 )Matrix {for _faf :=range _ec {_ec [_faf ]=_fa .Round (_ec [_faf ]/precision )*precision ;};return _ec ;};func (_gcb Point )String ()string {return _b .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_gcb .X ,_gcb .Y );
};func (_egc *Point )Set (x ,y float64 ){_egc .X ,_egc .Y =x ,y };func (_gb Matrix )Translation ()(float64 ,float64 ){return _gb [6],_gb [7]};type Matrix [9]float64 ;func (_adg Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_adg .X +t *b .X ,Y :(1-t )*_adg .Y +t *b .Y };
};func (_cbd *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_bd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_cbd .transformByMatrix (_bd );};const _afb =1.0e-6;func (_fb Matrix )Mult (b Matrix )Matrix {_fb .Concat (b );return _fb };func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};type Point struct{X float64 ;Y float64 ;};const _gg =1e-6;func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_fd Matrix )Unrealistic ()bool {_dfae ,_eb ,_ecb ,_gf :=_fa .Abs (_fd [0]),_fa .Abs (_fd [1]),_fa .Abs (_fd [3]),_fa .Abs (_fd [4]);
_gc :=_dfae > _gg &&_gf > _gg ;_ff :=_eb > _gg &&_ecb > _gg ;return !(_gc ||_ff );};