//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_da "encoding/binary";_d "errors";_f "fmt";_b "github.com/laduygaga/unipdf/v3/common";_gb "github.com/laduygaga/unipdf/v3/internal/jbig2/errors";_gc "io";);func (_efed *Writer )WriteByte (c byte )error {return _efed .writeByte (c )};
func (_gd *BufferedWriter )FinishByte (){if _gd ._gcc ==0{return ;};_gd ._gcc =0;_gd ._bb ++;};func (_dd *Reader )ReadUint32 ()(uint32 ,error ){_eab :=make ([]byte ,4);_ ,_cfdc :=_dd .Read (_eab );if _cfdc !=nil {return 0,_cfdc ;};return _da .BigEndian .Uint32 (_eab ),nil ;
};func (_deb *Reader )readBufferByte ()(byte ,error ){if _deb ._ebbg >=int64 (_deb ._ag ._cde ){return 0,_gc .EOF ;};_deb ._gbd =-1;_aec :=_deb ._ag ._bce [int64 (_deb ._ag ._fdg )+_deb ._ebbg ];_deb ._ebbg ++;_deb ._gf =int (_aec );return _aec ,nil ;};
func (_ddc *Reader )RelativePosition ()int64 {return _ddc ._ebbg };func (_dee *Writer )FinishByte (){if _dee ._bdg ==0{return ;};_dee ._bdg =0;_dee ._daf ++;};func (_aee *BufferedWriter )grow (_ea int ){if _aee ._ae ==nil &&_ea < _a {_aee ._ae =make ([]byte ,_ea ,_a );
return ;};_ed :=len (_aee ._ae );if _aee ._gcc !=0{_ed ++;};_fdd :=cap (_aee ._ae );switch {case _ea <=_fdd /2-_ed :_b .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_aee ._ae ),cap (_aee ._ae ),_ea );
_b .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_fdd ,_ed );copy (_aee ._ae ,_aee ._ae [_aee .fullOffset ():]);
case _fdd > _e -_fdd -_ea :_b .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ab :=make ([]byte ,2*_fdd +_ea );copy (_ab ,_aee ._ae );_aee ._ae =_ab ;};_aee ._ae =_aee ._ae [:_ed +_ea ];
};var _ _gc .ByteWriter =&BufferedWriter {};func (_ebff *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _ebff ._cf !=0{return _ebff .ReadBits (_ebff ._cf );};return 0,nil ;};func (_cb *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _gb .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_cb ._ae )-1< _cb ._bb {_cb .expandIfNeeded (1);};_gee :=_cb ._gcc ;if _cb ._ff {_gee =7-_cb ._gcc ;};_cb ._ae [_cb ._bb ]|=byte (uint16 (bit <<_gee )&0xff);_cb ._gcc ++;if _cb ._gcc ==8{_cb ._bb ++;_cb ._gcc =0;};return nil ;};var (_ _gc .Reader =&Reader {};
_ _gc .ByteReader =&Reader {};_ _gc .Seeker =&Reader {};_ StreamReader =&Reader {};);type StreamReader interface{_gc .Reader ;_gc .ByteReader ;_gc .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_cbe byte )(uint64 ,error );
ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};const (_a =64;_e =int (^uint (0)>>1););func (_gdf *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_gdf ._gbd =-1;_gdf ._cf =0;_gdf ._fbg =0;_gdf ._gf =0;
var _acd int64 ;switch whence {case _gc .SeekStart :_acd =offset ;case _gc .SeekCurrent :_acd =_gdf ._ebbg +offset ;case _gc .SeekEnd :_acd =int64 (_gdf ._ag ._cde )+offset ;default:return 0,_d .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _acd < 0{return 0,_d .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_gdf ._ebbg =_acd ;
_gdf ._cf =0;return _acd ,nil ;};func (_baf *Reader )AbsoluteLength ()uint64 {return uint64 (len (_baf ._ag ._bce ))};func (_adf *Writer )Write (p []byte )(int ,error ){if len (p )> _adf .byteCapacity (){return 0,_gc .EOF ;};for _ ,_efdd :=range p {if _fec :=_adf .writeByte (_efdd );
_fec !=nil {return 0,_fec ;};};return len (p ),nil ;};func (_eb *BufferedWriter )Reset (){_eb ._ae =_eb ._ae [:0];_eb ._bb =0;_eb ._gcc =0};type BitWriter interface{WriteBit (_ba int )error ;WriteBits (_ega uint64 ,_ecf int )(_fgd int ,_dgg error );FinishByte ();
SkipBits (_be int )error ;};func NewWriter (data []byte )*Writer {return &Writer {_gdc :data }};func (_gda *BufferedWriter )fullOffset ()int {_gg :=_gda ._bb ;if _gda ._gcc !=0{_gg ++;};return _gg ;};type Writer struct{_gdc []byte ;_bdg uint8 ;_daf int ;
_beb bool ;};type readerSource struct{_bce []byte ;_fdg int ;_cde int ;};func (_bg *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_dg :=int (_bg ._gcc )+skip ;if _dg >=0&&_dg < 8{_bg ._gcc =uint8 (_dg );return nil ;};_dg =int (_bg ._gcc )+_bg ._bb *8+skip ;
if _dg < 0{return _gb .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cc :=_dg /8;_ec :=_dg %8;_bg ._gcc =uint8 (_ec );
if _fc :=_cc -_bg ._bb ;_fc > 0&&len (_bg ._ae )-1< _cc {if _bg ._gcc !=0{_fc ++;};_bg .expandIfNeeded (_fc );};_bg ._bb =_cc ;return nil ;};var _ _gc .Writer =&BufferedWriter {};func (_eda *BufferedWriter )writeShiftedBytes (_db []byte )int {for _ ,_ebe :=range _db {_eda .writeByte (_ebe );
};return len (_db );};func (_bc *BufferedWriter )WriteBits (bits uint64 ,number int )(_eg int ,_fe error ){const _ebf ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_gb .Errorf (_ebf ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_ac :=number /8;if _ac > 0{_gde :=number -_ac *8;for _ce :=_ac -1;_ce >=0;_ce --{_cd :=byte ((bits >>uint (_ce *8+_gde ))&0xff);if _fe =_bc .WriteByte (_cd );_fe !=nil {return _eg ,_gb .Wrapf (_fe ,_ebf ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ac -_ce +1);
};};number -=_ac *8;if number ==0{return _ac ,nil ;};};var _egc int ;for _acc :=0;_acc < number ;_acc ++{if _bc ._ff {_egc =int ((bits >>uint (number -1-_acc ))&0x1);}else {_egc =int (bits &0x1);bits >>=1;};if _fe =_bc .WriteBit (_egc );_fe !=nil {return _eg ,_gb .Wrapf (_fe ,_ebf ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_acc );
};};return _ac ,nil ;};func (_edc *Writer )byteCapacity ()int {_aca :=len (_edc ._gdc )-_edc ._daf ;if _edc ._bdg !=0{_aca --;};return _aca ;};func (_deg *Reader )Mark (){_deg ._ca =_deg ._ebbg ;_deg ._ece =_deg ._cf ;_deg ._geb =_deg ._fbg ;_deg ._bfd =_deg ._gf ;
};func (_bbe *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _bbe .writeBit (uint8 (bit ));};return _gb .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_cgb *Writer )writeByte (_fdc byte )error {if _cgb ._daf > len (_cgb ._gdc )-1{return _gc .EOF ;};if _cgb ._daf ==len (_cgb ._gdc )-1&&_cgb ._bdg !=0{return _gc .EOF ;};if _cgb ._bdg ==0{_cgb ._gdc [_cgb ._daf ]=_fdc ;_cgb ._daf ++;return nil ;
};if _cgb ._beb {_cgb ._gdc [_cgb ._daf ]|=_fdc >>_cgb ._bdg ;_cgb ._daf ++;_cgb ._gdc [_cgb ._daf ]=byte (uint16 (_fdc )<<(8-_cgb ._bdg )&0xff);}else {_cgb ._gdc [_cgb ._daf ]|=byte (uint16 (_fdc )<<_cgb ._bdg &0xff);_cgb ._daf ++;_cgb ._gdc [_cgb ._daf ]=_fdc >>(8-_cgb ._bdg );
};return nil ;};func (_fg *BufferedWriter )Len ()int {return _fg .byteCapacity ()};func NewWriterMSB (data []byte )*Writer {return &Writer {_gdc :data ,_beb :true }};func (_fac *Reader )ReadBits (n byte )(_aag uint64 ,_gfd error ){if n < _fac ._cf {_fgc :=_fac ._cf -n ;
_aag =uint64 (_fac ._fbg >>_fgc );_fac ._fbg &=1<<_fgc -1;_fac ._cf =_fgc ;return _aag ,nil ;};if n > _fac ._cf {if _fac ._cf > 0{_aag =uint64 (_fac ._fbg );n -=_fac ._cf ;};for n >=8{_gfg ,_bd :=_fac .readBufferByte ();if _bd !=nil {return 0,_bd ;};_aag =_aag <<8+uint64 (_gfg );
n -=8;};if n > 0{if _fac ._fbg ,_gfd =_fac .readBufferByte ();_gfd !=nil {return 0,_gfd ;};_bgg :=8-n ;_aag =_aag <<n +uint64 (_fac ._fbg >>_bgg );_fac ._fbg &=1<<_bgg -1;_fac ._cf =_bgg ;}else {_fac ._cf =0;};return _aag ,nil ;};_fac ._cf =0;return uint64 (_fac ._fbg ),nil ;
};func (_bea *Reader )read (_cfe []byte )(int ,error ){if _bea ._ebbg >=int64 (_bea ._ag ._cde ){return 0,_gc .EOF ;};_bea ._gbd =-1;_gge :=copy (_cfe ,_bea ._ag ._bce [(int64 (_bea ._ag ._fdg )+_bea ._ebbg ):(_bea ._ag ._fdg +_bea ._ag ._cde )]);_bea ._ebbg +=int64 (_gge );
return _gge ,nil ;};func (_ef *BufferedWriter )WriteByte (bt byte )error {if _ef ._bb > len (_ef ._ae )-1||(_ef ._bb ==len (_ef ._ae )-1&&_ef ._gcc !=0){_ef .expandIfNeeded (1);};_ef .writeByte (bt );return nil ;};func (_efd *Reader )AbsolutePosition ()int64 {return _efd ._ebbg +int64 (_efd ._ag ._fdg )};
func (_bbf *Writer )SkipBits (skip int )error {const _dafc ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_cbd :=int (_bbf ._bdg )+skip ;if _cbd >=0&&_cbd < 8{_bbf ._bdg =uint8 (_cbd );return nil ;
};_cbd =int (_bbf ._bdg )+_bbf ._daf *8+skip ;if _cbd < 0{return _gb .Errorf (_dafc ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_aeef :=_cbd /8;_gff :=_cbd %8;_b .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_b .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_bbf ._bdg ,_bbf ._daf ,int (_bbf ._bdg )+(_bbf ._daf )*8,len (_bbf ._gdc ),cap (_bbf ._gdc ));
_b .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_cbd ,_gff );_bbf ._bdg =uint8 (_gff );if _efe :=_aeef -_bbf ._daf ;
_efe > 0&&len (_bbf ._gdc )-1< _aeef {_b .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_efe );return _gb .Errorf (_dafc ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_bbf ._daf =_aeef ;_b .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_bbf ._bdg ,_bbf ._daf );return nil ;};func (_gbb *Reader )readUnalignedByte ()(_egad byte ,_aff error ){_gcf :=_gbb ._cf ;
_egad =_gbb ._fbg <<(8-_gcf );_gbb ._fbg ,_aff =_gbb .readBufferByte ();if _aff !=nil {return 0,_aff ;};_egad |=_gbb ._fbg >>_gcf ;_gbb ._fbg &=1<<_gcf -1;return _egad ,nil ;};func (_fd *BufferedWriter )expandIfNeeded (_cdg int ){if !_fd .tryGrowByReslice (_cdg ){_fd .grow (_cdg );
};};func (_ee *BufferedWriter )Write (d []byte )(int ,error ){_ee .expandIfNeeded (len (d ));if _ee ._gcc ==0{return _ee .writeFullBytes (d ),nil ;};return _ee .writeShiftedBytes (d ),nil ;};func (_bbg *BufferedWriter )ResetBitIndex (){_bbg ._gcc =0};func NewReader (data []byte )*Reader {return &Reader {_ag :readerSource {_bce :data ,_cde :len (data ),_fdg :0}};
};func (_dca *Writer )ResetBit (){_dca ._bdg =0};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ff :true }};func (_fde *Reader )readBool ()(_fdgg bool ,_fea error ){if _fde ._cf ==0{_fde ._fbg ,_fea =_fde .readBufferByte ();if _fea !=nil {return false ,_fea ;
};_fdgg =(_fde ._fbg &0x80)!=0;_fde ._fbg ,_fde ._cf =_fde ._fbg &0x7f,7;return _fdgg ,nil ;};_fde ._cf --;_fdgg =(_fde ._fbg &(1<<_fde ._cf ))!=0;_fde ._fbg &=1<<_fde ._cf -1;return _fdgg ,nil ;};func (_c *BufferedWriter )Data ()[]byte {return _c ._ae };
func (_dab *BufferedWriter )writeFullBytes (_dc []byte )int {_ffd :=copy (_dab ._ae [_dab .fullOffset ():],_dc );_dab ._bb +=_ffd ;return _ffd ;};func (_gcae *Reader )Reset (){_gcae ._ebbg =_gcae ._ca ;_gcae ._cf =_gcae ._ece ;_gcae ._fbg =_gcae ._geb ;
_gcae ._gf =_gcae ._bfd ;};func (_eca *Reader )ReadBit ()(_fgf int ,_dcg error ){_gca ,_dcg :=_eca .readBool ();if _dcg !=nil {return 0,_dcg ;};if _gca {_fgf =1;};return _fgf ,nil ;};func (_dga *Reader )ReadBool ()(bool ,error ){return _dga .readBool ()};
func (_afg *Reader )ReadByte ()(byte ,error ){if _afg ._cf ==0{return _afg .readBufferByte ();};return _afg .readUnalignedByte ();};type Reader struct{_ag readerSource ;_fbg byte ;_cf byte ;_ebbg int64 ;_gf int ;_gbd int ;_ca int64 ;_ece byte ;_geb byte ;
_bfd int ;};func (_fbgc *Writer )UseMSB ()bool {return _fbgc ._beb };func (_bcb *BufferedWriter )byteCapacity ()int {_af :=len (_bcb ._ae )-_bcb ._bb ;if _bcb ._gcc !=0{_af --;};return _af ;};func (_cded *Reader )Read (p []byte )(_feb int ,_ffc error ){if _cded ._cf ==0{return _cded .read (p );
};for ;_feb < len (p );_feb ++{if p [_feb ],_ffc =_cded .readUnalignedByte ();_ffc !=nil {return 0,_ffc ;};};return _feb ,nil ;};var _ BinaryWriter =&BufferedWriter {};func (_fb *BufferedWriter )tryGrowByReslice (_ebb int )bool {if _bgf :=len (_fb ._ae );
_ebb <=cap (_fb ._ae )-_bgf {_fb ._ae =_fb ._ae [:_bgf +_ebb ];return true ;};return false ;};type BinaryWriter interface{BitWriter ;_gc .Writer ;_gc .ByteWriter ;Data ()[]byte ;};func (_fa *BufferedWriter )writeByte (_ad byte ){switch {case _fa ._gcc ==0:_fa ._ae [_fa ._bb ]=_ad ;
_fa ._bb ++;case _fa ._ff :_fa ._ae [_fa ._bb ]|=_ad >>_fa ._gcc ;_fa ._bb ++;_fa ._ae [_fa ._bb ]=byte (uint16 (_ad )<<(8-_fa ._gcc )&0xff);default:_fa ._ae [_fa ._bb ]|=byte (uint16 (_ad )<<_fa ._gcc &0xff);_fa ._bb ++;_fa ._ae [_fa ._bb ]=_ad >>(8-_fa ._gcc );
};};func (_agc *Writer )writeBit (_dae uint8 )error {if len (_agc ._gdc )-1< _agc ._daf {return _gc .EOF ;};_ecd :=_agc ._bdg ;if _agc ._beb {_ecd =7-_agc ._bdg ;};_agc ._gdc [_agc ._daf ]|=byte (uint16 (_dae <<_ecd )&0xff);_agc ._bdg ++;if _agc ._bdg ==8{_agc ._daf ++;
_agc ._bdg =0;};return nil ;};func (_gdg *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_d .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_gdg ._ag ._fdg +offset ;};if length > 0{_adc :=len (_gdg ._ag ._bce );if relative {_adc =_gdg ._ag ._cde ;};if offset +length > _adc {return nil ,_f .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_gdg ._ag ._cde );
};};if length < 0{_ccg :=len (_gdg ._ag ._bce );if relative {_ccg =_gdg ._ag ._cde ;};length =_ccg -offset ;};return &Reader {_ag :readerSource {_bce :_gdg ._ag ._bce ,_cde :length ,_fdg :offset }},nil ;};func (_ffg *Reader )Length ()uint64 {return uint64 (_ffg ._ag ._cde )};
func (_bac *Reader )BitPosition ()int {return int (_bac ._cf )};func (_cg *Writer )Data ()[]byte {return _cg ._gdc };type BufferedWriter struct{_ae []byte ;_gcc uint8 ;_bb int ;_ff bool ;};func (_ggg *Writer )WriteBits (bits uint64 ,number int )(_faf int ,_dbe error ){const _abf ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_gb .Errorf (_abf ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_fff :=number /8;if _fff > 0{_ged :=number -_fff *8;for _eff :=_fff -1;_eff >=0;_eff --{_dbf :=byte ((bits >>uint (_eff *8+_ged ))&0xff);if _dbe =_ggg .WriteByte (_dbf );_dbe !=nil {return _faf ,_gb .Wrapf (_dbe ,_abf ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fff -_eff +1);
};};number -=_fff *8;if number ==0{return _fff ,nil ;};};var _abb int ;for _ddg :=0;_ddg < number ;_ddg ++{if _ggg ._beb {_abb =int ((bits >>uint (number -1-_ddg ))&0x1);}else {_abb =int (bits &0x1);bits >>=1;};if _dbe =_ggg .WriteBit (_abb );_dbe !=nil {return _faf ,_gb .Wrapf (_dbe ,_abf ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ddg );
};};return _fff ,nil ;};func (_cdc *Reader )Align ()(_gba byte ){_gba =_cdc ._cf ;_cdc ._cf =0;return _gba };var _ BinaryWriter =&Writer {};