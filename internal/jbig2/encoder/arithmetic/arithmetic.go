//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_c "bytes";_f "github.com/laduygaga/unipdf/v3/common";_b "github.com/laduygaga/unipdf/v3/internal/jbig2/bitmap";_db "github.com/laduygaga/unipdf/v3/internal/jbig2/errors";_d "io";);func (_dfbc *Encoder )encodeInteger (_fcg Class ,_add int )error {const _bbc ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _add > 2000000000||_add < -2000000000{return _db .Errorf (_bbc ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_add );
};_aff :=_dfbc ._bg [_fcg ];_feda :=uint32 (1);var _gec int ;for ;;_gec ++{if _gg [_gec ]._be <=_add &&_gg [_gec ]._g >=_add {break ;};};if _add < 0{_add =-_add ;};_add -=int (_gg [_gec ]._ge );_ced :=_gg [_gec ]._ed ;for _cgdf :=uint8 (0);_cgdf < _gg [_gec ]._da ;
_cgdf ++{_dbdg :=_ced &1;if _dgd :=_dfbc .encodeBit (_aff ,_feda ,_dbdg );_dgd !=nil {return _db .Wrap (_dgd ,_bbc ,"");};_ced >>=1;if _feda &0x100> 0{_feda =(((_feda <<1)|uint32 (_dbdg ))&0x1ff)|0x100;}else {_feda =(_feda <<1)|uint32 (_dbdg );};};_add <<=32-_gg [_gec ]._eg ;
for _fbb :=uint8 (0);_fbb < _gg [_gec ]._eg ;_fbb ++{_fca :=uint8 ((uint32 (_add )&0x80000000)>>31);if _bdg :=_dfbc .encodeBit (_aff ,_feda ,_fca );_bdg !=nil {return _db .Wrap (_bdg ,_bbc ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_add <<=1;if _feda &0x100!=0{_feda =(((_feda <<1)|uint32 (_fca ))&0x1ff)|0x100;}else {_feda =(_feda <<1)|uint32 (_fca );};};return nil ;};func (_fcf *Encoder )code0 (_eff *codingContext ,_bf uint32 ,_efcd uint16 ,_gcg byte ){if _eff .mps (_bf )==0{_fcf .codeMPS (_eff ,_bf ,_efcd ,_gcg );
}else {_fcf .codeLPS (_eff ,_bf ,_efcd ,_gcg );};};func (_bfg *Encoder )encodeOOB (_gfb Class )error {_aag :=_bfg ._bg [_gfb ];_fge :=_bfg .encodeBit (_aag ,1,1);if _fge !=nil {return _fge ;};_fge =_bfg .encodeBit (_aag ,3,0);if _fge !=nil {return _fge ;
};_fge =_bfg .encodeBit (_aag ,6,0);if _fge !=nil {return _fge ;};_fge =_bfg .encodeBit (_aag ,12,0);if _fge !=nil {return _fge ;};return nil ;};func (_aaa *Encoder )lBlock (){if _aaa ._gbb >=0{_aaa .emit ();};_aaa ._gbb ++;_aaa ._bc =uint8 (_aaa ._ag >>19);
_aaa ._ag &=0x7ffff;_aaa ._gd =8;};func (_aec *Encoder )encodeIAID (_addg ,_dge int )error {if _aec ._fed ==nil {_aec ._fed =_fe (1<<uint (_addg ));};_ccg :=uint32 (1<<uint32 (_addg +1))-1;_dge <<=uint (32-_addg );_ggda :=uint32 (1);for _cag :=0;_cag < _addg ;
_cag ++{_dfc :=_ggda &_ccg ;_dgf :=uint8 ((uint32 (_dge )&0x80000000)>>31);if _ggdf :=_aec .encodeBit (_aec ._fed ,_dfc ,_dgf );_ggdf !=nil {return _ggdf ;};_ggda =(_ggda <<1)|uint32 (_dgf );_dge <<=1;};return nil ;};func (_dfb *Encoder )Final (){_dfb .flush ()};
func (_fec *Encoder )Init (){_fec ._eb =_fe (_cac );_fec ._ef =0x8000;_fec ._ag =0;_fec ._gd =12;_fec ._gbb =-1;_fec ._bc =0;_fec ._dg =0;_fec ._ada =make ([]byte ,_ec );for _fa :=0;_fa < len (_fec ._bg );_fa ++{_fec ._bg [_fa ]=_fe (512);};_fec ._fed =nil ;
};func (_cab *Encoder )EncodeOOB (proc Class )(_agd error ){_f .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _agd =_cab .encodeOOB (proc );
_agd !=nil {return _db .Wrap (_agd ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_efg *Encoder )flush (){_efg .setBits ();_efg ._ag <<=_efg ._gd ;_efg .byteOut ();_efg ._ag <<=_efg ._gd ;_efg .byteOut ();_efg .emit ();if _efg ._bc !=0xff{_efg ._gbb ++;
_efg ._bc =0xff;_efg .emit ();};_efg ._gbb ++;_efg ._bc =0xac;_efg ._gbb ++;_efg .emit ();};type intEncRangeS struct{_be ,_g int ;_ed ,_da uint8 ;_ge uint16 ;_eg uint8 ;};func (_gge *Encoder )dataSize ()int {return _ec *len (_gge ._gef )+_gge ._dg };func (_efe *Encoder )byteOut (){if _efe ._bc ==0xff{_efe .rBlock ();
return ;};if _efe ._ag < 0x8000000{_efe .lBlock ();return ;};_efe ._bc ++;if _efe ._bc !=0xff{_efe .lBlock ();return ;};_efe ._ag &=0x7ffffff;_efe .rBlock ();};func (_geca *Encoder )rBlock (){if _geca ._gbb >=0{_geca .emit ();};_geca ._gbb ++;_geca ._bc =uint8 (_geca ._ag >>20);
_geca ._ag &=0xfffff;_geca ._gd =7;};type Class int ;func (_dgg *Encoder )EncodeInteger (proc Class ,value int )(_bcb error ){_f .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _bcb =_dgg .encodeInteger (proc ,value );_bcb !=nil {return _db .Wrap (_bcb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_ceb *Encoder )Flush (){_ceb ._dg =0;_ceb ._gef =nil ;_ceb ._gbb =-1};
func New ()*Encoder {_geb :=&Encoder {};_geb .Init ();return _geb };func (_bb *Encoder )code1 (_edc *codingContext ,_egb uint32 ,_de uint16 ,_dec byte ){if _edc .mps (_egb )==1{_bb .codeMPS (_edc ,_egb ,_de ,_dec );}else {_bb .codeLPS (_edc ,_egb ,_de ,_dec );
};};func (_ee *codingContext )flipMps (_cf uint32 ){_ee ._a [_cf ]=1-_ee ._a [_cf ]};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);var _bfa =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_gaaca *Encoder )encodeBit (_fgd *codingContext ,_bcd uint32 ,_bge uint8 )error {const _gde ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_gaaca ._ce ++;if _bcd >=uint32 (len (_fgd ._gb )){return _db .Errorf (_gde ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_bcd );
};_dce :=_fgd ._gb [_bcd ];_cdg :=_fgd .mps (_bcd );_bbf :=_bfa [_dce ]._befa ;_f .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_gaaca ._ce ,_bge ,_dce ,_cdg ,_bbf ,_gaaca ._ef ,_gaaca ._ag ,_gaaca ._gd ,_gaaca ._bc ,_gaaca ._gbb );
if _bge ==0{_gaaca .code0 (_fgd ,_bcd ,_bbf ,_dce );}else {_gaaca .code1 (_fgd ,_bcd ,_bbf ,_dce );};return nil ;};func (_fd *Encoder )EncodeBitmap (bm *_b .Bitmap ,duplicateLineRemoval bool )error {_f .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_cd ,_eeg uint8 ;_fg ,_ae ,_aef uint16 ;_agf ,_df ,_dc byte ;_ga ,_ac ,_ggd int ;_bgc ,_ca []byte ;);for _gf :=0;_gf < bm .Height ;_gf ++{_agf ,_df =0,0;if _gf >=2{_agf =bm .Data [(_gf -2)*bm .RowStride ];};if _gf >=1{_df =bm .Data [(_gf -1)*bm .RowStride ];
if duplicateLineRemoval {_ac =_gf *bm .RowStride ;_bgc =bm .Data [_ac :_ac +bm .RowStride ];_ggd =(_gf -1)*bm .RowStride ;_ca =bm .Data [_ggd :_ggd +bm .RowStride ];if _c .Equal (_bgc ,_ca ){_eeg =_cd ^1;_cd =1;}else {_eeg =_cd ;_cd =0;};};};if duplicateLineRemoval {if _gefc :=_fd .encodeBit (_fd ._eb ,_dd ,_eeg );
_gefc !=nil {return _gefc ;};if _cd !=0{continue ;};};_dc =bm .Data [_gf *bm .RowStride ];_fg =uint16 (_agf >>5);_ae =uint16 (_df >>4);_agf <<=3;_df <<=4;_aef =0;for _ga =0;_ga < bm .Width ;_ga ++{_ebg :=uint32 (_fg <<11|_ae <<4|_aef );_gaa :=(_dc &0x80)>>7;
_bd :=_fd .encodeBit (_fd ._eb ,_ebg ,_gaa );if _bd !=nil {return _bd ;};_fg <<=1;_ae <<=1;_aef <<=1;_fg |=uint16 ((_agf &0x80)>>7);_ae |=uint16 ((_df &0x80)>>7);_aef |=uint16 (_gaa );_cea :=_ga %8;_cb :=_ga /8+1;if _cea ==4&&_gf >=2{_agf =0;if _cb < bm .RowStride {_agf =bm .Data [(_gf -2)*bm .RowStride +_cb ];
};}else {_agf <<=1;};if _cea ==3&&_gf >=1{_df =0;if _cb < bm .RowStride {_df =bm .Data [(_gf -1)*bm .RowStride +_cb ];};}else {_df <<=1;};if _cea ==7{_dc =0;if _cb < bm .RowStride {_dc =bm .Data [_gf *bm .RowStride +_cb ];};}else {_dc <<=1;};_fg &=31;_ae &=127;
_aef &=15;};};return nil ;};type state struct{_befa uint16 ;_fbc ,_adda uint8 ;_dad uint8 ;};var _ _d .WriterTo =&Encoder {};type Encoder struct{_ag uint32 ;_ef uint16 ;_gd ,_bc uint8 ;_gbb int ;_ce int ;_gef [][]byte ;_ada []byte ;_dg int ;_eb *codingContext ;
_bg [13]*codingContext ;_fed *codingContext ;};func (_fb Class )String ()string {switch _fb {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";
case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";
case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_bcf *Encoder )Refine (iTemp ,iTarget *_b .Bitmap ,ox ,oy int )error {for _ba :=0;
_ba < iTarget .Height ;_ba ++{var _bcg int ;_efc :=_ba +oy ;var (_ff ,_dbd ,_fba ,_ddc ,_agg uint16 ;_gab ,_ebc ,_agge ,_efbb ,_aca byte ;);if _efc >=1&&(_efc -1)< iTemp .Height {_gab =iTemp .Data [(_efc -1)*iTemp .RowStride ];};if _efc >=0&&_efc < iTemp .Height {_ebc =iTemp .Data [_efc *iTemp .RowStride ];
};if _efc >=-1&&_efc +1< iTemp .Height {_agge =iTemp .Data [(_efc +1)*iTemp .RowStride ];};if _ba >=1{_efbb =iTarget .Data [(_ba -1)*iTarget .RowStride ];};_aca =iTarget .Data [_ba *iTarget .RowStride ];_ea :=uint (6+ox );_ff =uint16 (_gab >>_ea );_dbd =uint16 (_ebc >>_ea );
_fba =uint16 (_agge >>_ea );_ddc =uint16 (_efbb >>6);_gc :=uint (2-ox );_gab <<=_gc ;_ebc <<=_gc ;_agge <<=_gc ;_efbb <<=2;for _bcg =0;_bcg < iTarget .Width ;_bcg ++{_eaf :=(_ff <<10)|(_dbd <<7)|(_fba <<4)|(_ddc <<1)|_agg ;_fac :=_aca >>7;_ddg :=_bcf .encodeBit (_bcf ._eb ,uint32 (_eaf ),_fac );
if _ddg !=nil {return _ddg ;};_ff <<=1;_dbd <<=1;_fba <<=1;_ddc <<=1;_ff |=uint16 (_gab >>7);_dbd |=uint16 (_ebc >>7);_fba |=uint16 (_agge >>7);_ddc |=uint16 (_efbb >>7);_agg =uint16 (_fac );_gbe :=_bcg %8;_acf :=_bcg /8+1;if _gbe ==5+ox {_gab ,_ebc ,_agge =0,0,0;
if _acf < iTemp .RowStride &&_efc >=1&&(_efc -1)< iTemp .Height {_gab =iTemp .Data [(_efc -1)*iTemp .RowStride +_acf ];};if _acf < iTemp .RowStride &&_efc >=0&&_efc < iTemp .Height {_ebc =iTemp .Data [_efc *iTemp .RowStride +_acf ];};if _acf < iTemp .RowStride &&_efc >=-1&&(_efc +1)< iTemp .Height {_agge =iTemp .Data [(_efc +1)*iTemp .RowStride +_acf ];
};}else {_gab <<=1;_ebc <<=1;_agge <<=1;};if _gbe ==5&&_ba >=1{_efbb =0;if _acf < iTarget .RowStride {_efbb =iTarget .Data [(_ba -1)*iTarget .RowStride +_acf ];};}else {_efbb <<=1;};if _gbe ==7{_aca =0;if _acf < iTarget .RowStride {_aca =iTarget .Data [_ba *iTarget .RowStride +_acf ];
};}else {_aca <<=1;};_ff &=7;_dbd &=7;_fba &=7;_ddc &=7;};};return nil ;};type codingContext struct{_gb []byte ;_a []byte ;};func (_agdf *Encoder )Reset (){_agdf ._ef =0x8000;_agdf ._ag =0;_agdf ._gd =12;_agdf ._gbb =-1;_agdf ._bc =0;_agdf ._fed =nil ;
_agdf ._eb =_fe (_cac );};func (_ede *Encoder )emit (){if _ede ._dg ==_ec {_ede ._gef =append (_ede ._gef ,_ede ._ada );_ede ._ada =make ([]byte ,_ec );_ede ._dg =0;};_ede ._ada [_ede ._dg ]=_ede ._bc ;_ede ._dg ++;};func (_edd *Encoder )codeLPS (_gee *codingContext ,_bbg uint32 ,_fdg uint16 ,_agc byte ){_edd ._ef -=_fdg ;
if _edd ._ef < _fdg {_edd ._ag +=uint32 (_fdg );}else {_edd ._ef =_fdg ;};if _bfa [_agc ]._dad ==1{_gee .flipMps (_bbg );};_gee ._gb [_bbg ]=_bfa [_agc ]._adda ;_edd .renormalize ();};func (_bgcf *Encoder )setBits (){_dfe :=_bgcf ._ag +uint32 (_bgcf ._ef );
_bgcf ._ag |=0xffff;if _bgcf ._ag >=_dfe {_bgcf ._ag -=0x8000;};};const _dd =0x9b25;func (_bca *Encoder )renormalize (){for {_bca ._ef <<=1;_bca ._ag <<=1;_bca ._gd --;if _bca ._gd ==0{_bca .byteOut ();};if (_bca ._ef &0x8000)!=0{break ;};};};func (_cc *Encoder )WriteTo (w _d .Writer )(int64 ,error ){const _dde ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _eaff int64 ;for _fc ,_aa :=range _cc ._gef {_acd ,_bef :=w .Write (_aa );if _bef !=nil {return 0,_db .Wrapf (_bef ,_dde ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_fc );
};_eaff +=int64 (_acd );};_cc ._ada =_cc ._ada [:_cc ._dg ];_gga ,_gaac :=w .Write (_cc ._ada );if _gaac !=nil {return 0,_db .Wrap (_gaac ,_dde ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_eaff +=int64 (_gga );
return _eaff ,nil ;};func (_edcb *Encoder )codeMPS (_bfe *codingContext ,_cgf uint32 ,_dbe uint16 ,_cgd byte ){_edcb ._ef -=_dbe ;if _edcb ._ef &0x8000!=0{_edcb ._ag +=uint32 (_dbe );return ;};if _edcb ._ef < _dbe {_edcb ._ef =_dbe ;}else {_edcb ._ag +=uint32 (_dbe );
};_bfe ._gb [_cgf ]=_bfa [_cgd ]._fbc ;_edcb .renormalize ();};var _gg =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_af *Encoder )EncodeIAID (symbolCodeLength ,value int )(_dfa error ){_f .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _dfa =_af .encodeIAID (symbolCodeLength ,value );_dfa !=nil {return _db .Wrap (_dfa ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_ad *codingContext )mps (_cg uint32 )int {return int (_ad ._a [_cg ])};func _fe (_fbg int )*codingContext {return &codingContext {_gb :make ([]byte ,_fbg ),_a :make ([]byte ,_fbg )};
};func (_efb *Encoder )DataSize ()int {return _efb .dataSize ()};const (_cac =65536;_ec =20*1024;);